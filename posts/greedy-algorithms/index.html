<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.55.6" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Zhitao Lin" />
  <meta property="og:url" content="http://liamlin.top/posts/greedy-algorithms/" />
  <link rel="canonical" href="http://liamlin.top/posts/greedy-algorithms/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "http:\/\/liamlin.top\/"
      },
      "articleSection" : "posts",
      "name" : "Greedy Algorithms",
      "headline" : "Greedy Algorithms",
      "description" : "Part one -- Minimum Spanning Tree part two -- The Interval Partitioning Problem part three -- The Interval Partitioning Problem part four -- Huffman Coding part five -- The 0-1 Knapsack Problem part six -- The Weighted Interval Scheduling Problem part seven -- Reference  Greedy Algorithms typically used to solve optimization problems where one has to make a series of choices. The main idea is to choose in a locally optimized manner, that is being greedy, focusing on the temporary profits and to have no worry about the future.",
      "inLanguage" : "en-US",
      "author" : "Zhitao Lin",
      "creator" : "Zhitao Lin",
      "publisher": "Zhitao Lin",
      "accountablePerson" : "Zhitao Lin",
      "copyrightHolder" : "Zhitao Lin",
      "copyrightYear" : "2019",
      "datePublished": "2019-07-08 21:53:48 -0400 EDT",
      "dateModified" : "2019-07-08 21:53:48 -0400 EDT",
      "url" : "http:\/\/liamlin.top\/posts\/greedy-algorithms\/",
      "keywords" : [  ]
  }
</script>
<title>Greedy Algorithms - Zhitao Lin&#39;s Site</title>
  <meta property="og:title" content="Greedy Algorithms - Zhitao Lin&#39;s Site" />
  <meta property="og:type" content="article" />
  <meta name="description" content="Part one -- Minimum Spanning Tree part two -- The Interval Partitioning Problem part three -- The Interval Partitioning Problem part four -- Huffman Coding part five -- The 0-1 Knapsack Problem part six -- The Weighted Interval Scheduling Problem part seven -- Reference  Greedy Algorithms typically used to solve optimization problems where one has to make a series of choices. The main idea is to choose in a locally optimized manner, that is being greedy, focusing on the temporary profits and to have no worry about the future." />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="Zhitao Lin&#39;s Site">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Zhitao Lin</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Greedy Algorithms</h1>
          <div class="row">
            <div class="col-xs-6">
              <time class="post-date" datetime="2019-07-08 21:53:48 EDT">
                08, Jul, 2019
              </time>
            </div>
            <div class="col-xs-6">
              <div class="post-author">
                <a target="_blank" href="./">@Zhitao Lin</a>
              </div>
            </div>
          </div>
        </header>

        <div class="post-content markdown-body">
          

<pre>
Part one   -- Minimum Spanning Tree
part two   -- The Interval Partitioning Problem
part three -- The Interval Partitioning Problem
part four  -- Huffman Coding
part five  -- The 0-1 Knapsack Problem
part six   -- The Weighted Interval Scheduling Problem
part seven -- Reference
</pre>

<p>Greedy Algorithms typically used to solve optimization problems where one has to make a series of choices. The main idea is to choose in a locally optimized manner, that is being greedy, focusing on the temporary profits and to have no worry about the future. However, the funny and also tricky part is that you want to finally have the best result. It is like you playing a game that consists of many small games, and you are going to win the easiest small games one by one, and you know that you are going to be the final winner.</p>

<p>In common sense, to win the easiest games is easy, but to make sure that by winning the easiest games you can win the whole game is not. Thus, to make a locally optimal choice is easy for constructing a greedy algorithm, but prove that the solution constructed by the greedy algorithm is always as good as the globally optimal solution is hard. Now you should what I am trying to say. Generally, we use induction and contradiction (sometimes even mix them together) to prove the correctness of a greedy algorithm.</p>

<p>Let go through some examples from Introduction to Algorithm to see how greedy Greedy Algorithms are.</p>

<h2 id="minimum-spanning-tree">Minimum Spanning Tree</h2>

<p>This a classic example of using the Greedy Algorithm.</p>

<p><strong>Input</strong>: An edge-weighted, connected, undirected graph $G$ with vertex set $V$ and edge set $E$.<br />
<strong>Output</strong>: A tree of minimum total edge-weight that connects all vertices in $V$.</p>

<p>There are two famous greedy algorithms for computing a minimum spanning tree.</p>

<ul>
<li>Prim’s Algorithm</li>
<li>Kruskals’ Algorithm</li>
</ul>

<h3 id="prim-s-algorithm">Prim’s Algorithm:</h3>

<h4 id="pseudocode">Pseudocode</h4>

<ol>
<li>Start with any v in V</li>
<li>Choose add a shortest edge that connects with our tree to our tree, until every v include in our tree</li>
<li>Our tree is the minimum spanning tree</li>
</ol>

<h4 id="proof">Proof</h4>

<p><em>Claim</em>: Our tree $T$ is always the subtree of the optimized tree $T_o$</p>

<p><em>Base Case</em>: We Start with any $v\in V$ =&gt; Claim is true</p>

<p><em>General Case</em>:  We add edge $r_n$ to our tree, if the new tree belongs to $T_o$ we are good.
Otherwise, there must be a cycle $c$ that connects the new vertex and our tree. But as we know, $e_n &lt;= \forall e \in E$ and $e_n &lt;= c$. Thus, replace $c$ with $e$. We are Good.</p>

<h3 id="kruskals-algorithm">Kruskals’ Algorithm</h3>

<h4 id="pseudocode-1">Pseudocode</h4>

<ol>
<li>Add the shortest edge to our tree, whose two connected vertices are not both included, until we add all vertices</li>
<li>Our tree is the minimum spanning tree</li>
</ol>

<p>The proof is similar to the Prim’s.</p>

<h2 id="interval-scheduling">Interval Scheduling:</h2>

<h3 id="problem-description">Problem Description</h3>

<p><strong>Input</strong>: $A$ set $S$ of intervals on a line <br />
<strong>Output</strong>: A largest subset $S_{l}$ of $S$ such that no two intervals in $S_l$ overlap</p>

<p>We have one classroom and different courses begin and finish at different times. How can we arrange the best schedule to have as many courses as possible?</p>

<h3 id="earliest-finish-time">Earliest Finish Time</h3>

<p>We can use the Earliest Finish Time Strategy (Greedy) to solve this problem.</p>

<p>However, can we use the Earliest start time, Shortest interval, Fewest conflicts Strategy? Nope! You can try to get some counterexamples.</p>

<h3 id="proof-1">Proof:</h3>

<p><em>Base case</em>: we schedule our first course, $C_1$, that is finished earliest among all courses. We are good.</p>

<p><em>General case</em>: We choose another one, say $C_2$. If in the optimized schedule, after we choose $C_1$, we choose $C_3$, not $C_2$. However, according to our strategy, we have $C_2 &lt;= C_3$ in terms of finishing time. We can replace $C_3$ with $C_2$. We are still good because there are no other courses even exists between $C_2$ and $C_3$.</p>

<pre>
Greedy:        c1__|__c2____|__     <<<---Why can’t we just replace c3 with c2?--->>>
Optimized:     c1__|_____c3_|__
</pre>

<h2 id="the-interval-partitioning-problem">The Interval Partitioning Problem</h2>

<h3 id="problem-description-1">Problem Description</h3>

<p>We have a lot of classrooms and courses. How can we come up with a schedule where uses as fewer classrooms as possible to finish all courses?</p>

<h3 id="earliest-start-time-first">Earliest-start-time first</h3>

<p>The earliest-start-time first algorithm.</p>

<p><em>Base case</em>: We use one classroom for the first start course. We are good.</p>

<p><em>General case</em>: If we don’t need to use a new classroom. We are good.
If we need to use a new classroom: presume the start time of the course is $t$. If we need to use a new classroom, it means that all other classrooms are occupied at the time $t$. Thus, the classroom number of all possible schedules $&gt;=$ the number after we use a new classroom. We are good.</p>

<h2 id="huffman-coding">Huffman Coding</h2>

<h3 id="problem-description-2">Problem Description</h3>

<p><strong>Input</strong>: A frequency table for the di erent characters in a file F.<br />
<strong>Output</strong>: A prefix-free code for F that minimizes the length of the encoded file.</p>

<p>The time complexity is O(nlogn) if we use the priority queue.</p>

<p>It is a very straightforward algorithm, we build the code tree bottom-up.</p>

<h3 id="example">Example</h3>

<p>We have:</p>

<pre><code>f-5 e-9 c-12 b-13 d-16 a-45

           86
         /   \
        41    a
      /    \
    16     25           &lt;---- Result, A Huffman Tree
   /  \   /  \
  14   d c    b
 /  \     
f    e    
</code></pre>

<h2 id="the-0-1-knapsack-problem">The 0-1 Knapsack Problem</h2>

<p>Sometimes, the greedy algorithm fails.</p>

<h3 id="problem-description-3">Problem Description</h3>

<p>We have a knapsack that can hold $W$ pounds item. And there is a set of items with different weights $w$ and different values $v$. How can we maximize the value?</p>

<h3 id="example-1">Example</h3>

<p>If you want to apply the greedy algorithm, we may pick the most valuable and light item first, that is to pick the item with the smallest $v/w$, until we cannot put one more item into the knapsack. However, here is a counterexample:</p>

<pre>
         W=50 
v1=60,  w1=10, v1/w1=6
v2=100, w2=20, v1/w1=5
v3=120, w3=30, v1/w1=4
</pre>

<p>So we pick $v1$ and $v_2$, and we cannot pick $v_3$ because I only have room for 20 pounds item after we picked $v_1$ and $v_2$. Finally, our knapsack values 160.</p>

<p>However, if we pick $v_2$ and $v_3$, where $w_2 + w_3 = W$, our knapsack values 220.</p>

<p>Greedy Algorithm fails. (We should use dynamic programming to solve this problem.)</p>

<p>However, it works for the fractional knapsack problem, where I can pick a fraction of items, not to pick nothing versus everything.</p>

<h2 id="the-weighted-interval-scheduling-problem">The Weighted Interval Scheduling Problem</h2>

<p>Comparing with the unweighted interval scheduling problem, each interval(course) has weight. Thus we are not looking for the highest number of courses but the highest weight with which the courses sum up.</p>

<p>You can find a counterexample that greedy algorithm fails easily.</p>

<h2 id="reference">Reference</h2>

<p>Cormen, Thomas H., et al. Introduction to algorithms. MIT press, 2009.</p>

        </div>
        
        
        
        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="./about-me" target="_blank">About Me</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/liamlin88" target="_blank">Github</a>
  </div>
  
  <div class="site-footer-item">
  </div>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$']],
        displayMath: [['$$','$$']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { equationNumbers: { autoNumber: "AMS" },
             extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
    </script>

</div>

      </div>
    </div>
  </article>

  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$']],
        displayMath: [['$$','$$']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { equationNumbers: { autoNumber: "AMS" },
             extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
    </script>

  <script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>



  

</body>

</html>